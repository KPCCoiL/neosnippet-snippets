snippet     warshallFloyd
abbr        for()for()for()d[][]=min();
options     head
        for(int k = 0; k < ${1:Vertex}; k++)
                for(int i = 0; i < $1; i++)
                        for(int j = 0; j < $1; j++)
                                ${2:Distance}[i][j] = min($2[i][j],$2[i][k]+$2[k][j]);
        ${0}
        
snippet     bfs
abbr        while(!q.empty()){}
options     head
        queue<${1:type}> ${2:Queue};
        while(!$2.empty()) {
                $1 now = $2.front(); $2.pop();
                ${0}
        }

snippet     unionFind
alias       ufind
abbr        class union_find{}
options     head
        class union_find {
                vector<int> rank, par;
                public:
                        union_find(int n) : rank(n,1), par(n) {
                                for (int i = 0; i < n; i++)
                                	par[i] = i;
                        }
                        int find(int x) {
                                if(par[x] == x) return x;
                                return par[x] = find(par[x]);
                        }
                        void unite(int x, int y) {
                                x = find(x);
                                y = find(y);
                                if(rank[x] < rank[y]) par[x] = y;
                                else {
                                        par[y] = x;
                                        if(rank[x] == rank[y])
                                                rank[x]++;
                                }
                        }
                        bool same(int x, int y) { return find(x) == find(y); }
        };
        ${0}

snippet     montecalro
abbr        start;while(now<time){}
options     head
        auto start = chrono::system_clock::now();
        while (chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now()-start).count() < ${1:TimeLimit}) {
                ${0}
        }

snippet     dijkLoop
abbr        while(){for()if()v;for()d[][]=min();}
options     head
        vector<bool> used(${1:Vectex},false);
	while (true) {
		int v = -1;
		for (int i = 0; i < $1; i++)
			if (!used[i] && (v == -1 || ${2:Distance}[i] < $2[v]))
				v = i;
		if (v == -1) break;
		used[v] = true;
		for (int i = 0; i < $1; i++)
			$2[i] = min($2[i], $2[v]+${3:Cost}[v][i]);
	}
	${0}
	
snippet     edgeComp
abbr        struct edge{operator<(){}};
options     head
        struct edge {
                int u,v,cost;
                bool operator< (edge const& e) {
                        return this->cost < e.cost;
                }
        };
        ${0}

snippet     kruskal
abbr        sort()for(){if(!same())unite()}
options     head
	sort(begin(${1:Edges}),end($1));
	union_find uf(${2:Vertex});
	int ${3:Result} = 0;
	for (edge& i : $1) {
		if (!uf.same(i.u, i.v)) {
			uf.unite(i.u, i.v);
			$3 += i.cost;
		}
	}
	${0}
