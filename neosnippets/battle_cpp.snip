snippet     warshallFloyd
abbr        for()for()for()d[][]=min();
options     head
        for(int k = 0; k < ${1:Vertex}; k++)
                for(int i = 0; i < $1; i++)
                        for(int j = 0; j < $1; j++)
                               ${2:Distance}[i][j] = min($2[i][j],$2[i][k]+$2[k][j]);
        ${0}
        
snippet     bfs
abbr        while(!q.empty()){}
options     head
        queue<${1:type}> ${2:Queue};
        while(!$2.empty()) {
                $1 now = $2.front(); $2.pop();
                ${0}
        }

snippet     unionFind
alias       ufind
abbr        class union_find{}
options     head
        class union_find {
                vector<int> rank, par;
                public:
                        union_find(int n) : rank(n,1), par(n) {
                                for (int i = 0; i < n; i++)
                                	par[i] = i;
                        }
                        int find(int x) {
                                if(par[x] == x) return x;
                                return par[x] = find(par[x]);
                        }
                        void unite(int x, int y) {
                                x = find(x);
                                y = find(y);
                                if(rank[x] < rank[y]) par[x] = y;
                                else {
                                        par[y] = x;
                                        if(rank[x] == rank[y])
                                                rank[x]++;
                                }
                        }
                        bool same(int x, int y) { return find(x) == find(y); }
        };
        ${0}

snippet     montecalro
abbr        start;while(now<time){}
options     head
        using namespace chrono;
        auto start = system_clock::now();
        while (duration_cast<milliseconds>(system_clock::now()-start).count() < ${1:TimeLimit}) {
                ${0}
        }

snippet     dijkLoop
abbr        while(){for()if()v;for()d[][]=min();}
options     head
        vector<bool> used(${1:Vectex},false);
        while (true) {
                int v = -1;
                for (int i = 0; i < $1; i++)
                        if (!used[i] && (v == -1 || ${2:Distance}[i] < $2[v]))
				v = i;
                if (v == -1) break;
                used[v] = true;
                for (int i = 0; i < $1; i++)
                        $2[i] = min($2[i], $2[v]+${3:Cost}[v][i]);
        }
        ${0}
	
snippet     edgeComp
abbr        struct edge{operator<(){}};
options     head
        struct edge {
                int u,v,cost;
                bool operator< (edge const& e) {
                        return this->cost < e.cost;
                }
        };
        ${0}

snippet     kruskal
abbr        sort()for(){if(!same())unite()}
options     head
        sort(begin(${1:Edges}),end($1));
        union_find uf(${2:Vertex});
        int ${3:Result} = 0;
        for (edge& i : $1) {
                if (!uf.same(i.u, i.v)) {
                        uf.unite(i.u, i.v);
                        $3 += i.cost;
                }
        }
        ${0}

snippet     dijkQueue
abbr        que.emp();while(){pop();for()d[]=min();}
options     head
        ${1:Distance}[${2:Start}] = 0;
        using pii = pair<int,int>;
        priority_queue<pii,vector<pii>,greater<pii>> que;
        que.emplace(0,$2);
        while (!que.empty()) {
                auto now = que.top(); que.pop();
                int v = now.second;
                if ($1[v] < now.first) continue;
                for (auto& i : ${3:Edges}[i]) {
                        if ($1[i.to] > $1[v]+i.cost) {
                                $1[i.to] = $1[v]+i.cost;
                                que.emplace($1[i.to], $1.to);
                        }
                }
        }
        ${0}
        
snippet     bellmanFord
abbr        while(){for()d[]=min();if(!update)break;}
options     head
        ${1:Distance}[${2:Start}] = 0;
        while (true) {
                bool update = false;
                for (auto& i : ${3:Edges}) {
                        if ($1[i.from] != INF && $1[i.to] > $1[i.from]+i.cost) {
                                $1[i.to] = $1[i.from]+i.cost;
                                update = true;
                        }
                }
                if (!update) break;
        }
        ${0}
